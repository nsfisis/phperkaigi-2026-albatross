package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"slices"
	"strings"
	"text/template"
)

func main() {
	inputFile := flag.String("i", "", "input file")
	outputFile := flag.String("o", "", "output file")
	flag.Parse()

	if inputFile == nil || *inputFile == "" || outputFile == nil || *outputFile == "" {
		flag.PrintDefaults()
		os.Exit(1)
	}

	// Parse the input file
	fileSet := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fileSet, *inputFile, nil, parser.SkipObjectResolution)
	if err != nil {
		panic(err)
	}

	// Find methods in StrictServerInterface
	var methods []string
	for _, decl := range parsedFile.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if typeSpec.Name.Name != "StrictServerInterface" {
				continue
			}
			interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}
			for _, method := range interfaceType.Methods.List {
				if len(method.Names) != 0 {
					methods = append(methods, method.Names[0].Name)
				}
			}
		}
	}
	if len(methods) == 0 {
		panic("StrictServerInterface not found")
	}
	slices.Sort(methods)

	loginOptionalMethods := map[string]bool{
		"GetGames":                 true,
		"GetGame":                  true,
		"GetGameWatchLatestStates": true,
		"GetGameWatchRanking":      true,
		"GetTournament":            true,
	}

	type TemplateParameter struct {
		Name              string
		RequiresLogin     bool
		LoginOptional     bool
		RequiresAdminRole bool
	}
	templateParameters := make([]TemplateParameter, len(methods))
	for i, method := range methods {
		templateParameters[i] = TemplateParameter{
			Name:              method,
			RequiresLogin:     method != "PostLogin" && !loginOptionalMethods[method],
			LoginOptional:     loginOptionalMethods[method],
			RequiresAdminRole: strings.Contains(method, "Admin"),
		}
	}

	// Generate code.
	tmpl, err := template.New("code").Parse(templateText)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, templateParameters)
	if err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(*outputFile, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

const templateText = `// Code generated by go generate; DO NOT EDIT.

package api

import (
	"context"

	"albatross-2026-backend/config"
	"albatross-2026-backend/db"
	"albatross-2026-backend/game"
	"albatross-2026-backend/session"
	"albatross-2026-backend/tournament"
)

var _ StrictServerInterface = (*HandlerWrapper)(nil)

type HandlerWrapper struct {
	impl Handler
}

func NewHandler(gameSvc *game.Service, tournamentSvc *tournament.Service, auth AuthenticatorInterface, queries db.Querier, conf *config.Config) *HandlerWrapper {
	return &HandlerWrapper{
		impl: Handler{
			gameSvc:       gameSvc,
			tournamentSvc: tournamentSvc,
			auth:          auth,
			conf:          conf,
			q:             queries,
		},
	}
}

{{ range . }}
	func (h *HandlerWrapper) {{ .Name }}(ctx context.Context, request {{ .Name }}RequestObject) ({{ .Name }}ResponseObject, error) {
		{{ if .RequiresLogin -}}
			user, ok := session.GetUserFromContext(ctx)
			if !ok {
				return {{ .Name }}401JSONResponse{
					Message: "Unauthorized",
				}, nil
			}
			{{ if .RequiresAdminRole -}}
				if !user.IsAdmin {
					return {{ .Name }}403JSONResponse{
						Message: "Forbidden",
					}, nil
				}
			{{ end -}}
			return h.impl.{{ .Name }}(ctx, request, user)
		{{ else if .LoginOptional -}}
			user, _ := session.GetUserFromContext(ctx)
			return h.impl.{{ .Name }}(ctx, request, user)
		{{ else -}}
			return h.impl.{{ .Name }}(ctx, request)
		{{ end -}}
	}
{{ end }}
`
